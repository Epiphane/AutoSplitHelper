// This file has been automatically generated by the Unreal Header Implementation tool

#include "FGBuildEffectActor.h"
#include "Components/SceneComponent.h"
#include "ItemAmount.h"

AFGBuildEffectActor::AFGBuildEffectActor() : Super() {
	this->mCurrentMaterializeAmount = 0.0;
	this->mMaterializeAmountPerThrow = 0.0;
	this->mEndStageSpeed = 1.0;
	this->mOffsetCurve.EditorCurveData.DefaultValue = 3.40282e+38;
	this->mOffsetCurve.EditorCurveData.PreInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mOffsetCurve.EditorCurveData.PostInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mOffsetCurve.ExternalCurve = nullptr;
	this->mVolumeCurve.EditorCurveData.DefaultValue = 3.40282e+38;
	this->mVolumeCurve.EditorCurveData.PreInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mVolumeCurve.EditorCurveData.PostInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mVolumeCurve.ExternalCurve = nullptr;
	this->mGlowCurve.EditorCurveData.DefaultValue = 3.40282e+38;
	this->mGlowCurve.EditorCurveData.PreInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mGlowCurve.EditorCurveData.PostInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mGlowCurve.ExternalCurve = nullptr;
	this->mFadeCurve.EditorCurveData.DefaultValue = 3.40282e+38;
	this->mFadeCurve.EditorCurveData.PreInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mFadeCurve.EditorCurveData.PostInfinityExtrap = ERichCurveExtrapolation::RCCE_Constant;
	this->mFadeCurve.ExternalCurve = nullptr;
	this->mShouldDelayBelts = true;
	this->splineBuildEffectSpeed = 0.0;
	this->mSplineDelayOffset = -0.2;
	this->mThumbSoundPlayTime = 1.0;
	this->mBounds = FBox(FVector::ZeroVector, FVector::ZeroVector);
	this->mBuildEffectMaterial = nullptr;
	this->mBuildEffectSplineMaterial = nullptr;
	this->mIsSpline = false;
	this->PrimaryActorTick.TickGroup = ETickingGroup::TG_PrePhysics;
	this->PrimaryActorTick.EndTickGroup = ETickingGroup::TG_PrePhysics;
	this->PrimaryActorTick.bTickEvenWhenPaused = false;
	this->PrimaryActorTick.bCanEverTick = true;
	this->PrimaryActorTick.bStartWithTickEnabled = false;
	this->PrimaryActorTick.bAllowTickOnDedicatedServer = true;
	this->PrimaryActorTick.TickInterval = 0.0;
	this->RootComponent = CreateDefaultSubobject<USceneComponent>(TEXT("Root"));
}
void AFGBuildEffectActor::Tick(float DeltaTime){ }
void AFGBuildEffectActor::CreateVisuals(){ }
TArray<UMeshComponent*> AFGBuildEffectActor::CreateStaticMesh(UMeshComponent* SourceComponent, const FTransform& sourceActorTransform){ return TArray<UMeshComponent*>(); }
void AFGBuildEffectActor::SetupThrowQueue(){ }
void AFGBuildEffectActor::SetRecipe(TSubclassOf<UFGRecipe> inRecipe, AFGBuildable* buildable){ }
float AFGBuildEffectActor::GetTotalSplineLength() const{ return float(); }
FTransform AFGBuildEffectActor::GetTransformOnSplines(bool bWorldSpace) const{ return FTransform(); }
FBuildEffectEnded& AFGBuildEffectActor::GetBind(UClass* actorClass){ return *(new FBuildEffectEnded); }
void AFGBuildEffectActor::UpdateCostQueue(){ }
void AFGBuildEffectActor::OnCostActorReachedTarget(){ }
void AFGBuildEffectActor::Start(){ }
void AFGBuildEffectActor::Stop(){ }
void AFGBuildEffectActor::UpdateSplineBuildables(float Dt){ }
void AFGBuildEffectActor::UpdateGenericBuildables(float Dt){ }
void AFGBuildEffectActor::UpdateWires(){ }
void AFGBuildEffectActor::CalculateBuildEffectBounds(){ }
TArray<class USplineComponent*> AFGBuildEffectActor::GetBeltSourceSplinesOrdered(const TArray<class AFGBuildableConveyorBelt*>& inBelts, TArray<AActor*>& orderedActors) const{ return TArray<class USplineComponent*>(); }
TArray<class USplineComponent*> AFGBuildEffectActor::GetPipeSourceSplineOrdered(const TArray<class AFGBuildablePipeBase*>& inPipes, TArray<AActor*>& orderedActors) const{ return TArray<class USplineComponent*>(); }
